diff --git a/hash.cpp b/hash.cpp
index 26150e5..d56e688 100644
--- a/hash.cpp
+++ b/hash.cpp
@@ -6,6 +6,7 @@
 #include <crypto/common.h>
 #include <crypto/hmac_sha512.h>
 
+bool CHashWriter::debug = false;
 
 inline uint32_t ROTL32(uint32_t x, int8_t r)
 {
diff --git a/hash.h b/hash.h
index c295568..8bce8db 100644
--- a/hash.h
+++ b/hash.h
@@ -6,16 +6,18 @@
 #ifndef BITCOIN_HASH_H
 #define BITCOIN_HASH_H
 
-#include <crypto/common.h>
 #include <crypto/ripemd160.h>
 #include <crypto/sha256.h>
 #include <prevector.h>
 #include <serialize.h>
 #include <uint256.h>
-#include <version.h>
 
 #include <vector>
 
+// version.h {
+static const int PROTOCOL_VERSION = 70015;
+// } // version.h
+
 typedef uint256 ChainCode;
 
 /** A hasher class for Bitcoin's 256-bit hash (double SHA-256). */
@@ -122,6 +124,7 @@ private:
     const int nType;
     const int nVersion;
 public:
+    static bool debug;
 
     CHashWriter(int nTypeIn, int nVersionIn) : nType(nTypeIn), nVersion(nVersionIn) {}
 
@@ -129,6 +132,10 @@ public:
     int GetVersion() const { return nVersion; }
 
     void write(const char *pch, size_t size) {
+        if (debug) {
+            printf("#%03zu ", size); for (size_t i = 0; i < size; i++) printf("%02x", (uint8_t)pch[i]);
+            printf("\n");
+        }
         ctx.Write((const unsigned char*)pch, size);
     }
 
@@ -139,15 +146,6 @@ public:
         return result;
     }
 
-    /**
-     * Returns the first 64 bits from the resulting hash.
-     */
-    inline uint64_t GetCheapHash() {
-        unsigned char result[CHash256::OUTPUT_SIZE];
-        ctx.Finalize(result);
-        return ReadLE64(result);
-    }
-
     template<typename T>
     CHashWriter& operator<<(const T& obj) {
         // Serialize to this stream
diff --git a/policy/policy.h b/policy/policy.h
index ebe040f..9ec79ad 100644
--- a/policy/policy.h
+++ b/policy/policy.h
@@ -6,48 +6,31 @@
 #ifndef BITCOIN_POLICY_POLICY_H
 #define BITCOIN_POLICY_POLICY_H
 
-#include <consensus/consensus.h>
-#include <policy/feerate.h>
 #include <script/interpreter.h>
-#include <script/standard.h>
 
 #include <string>
 
-class CCoinsViewCache;
-class CTxOut;
+// script/standard.h {
+/**
+ * Mandatory script verification flags that all new blocks must comply with for
+ * them to be valid. (but old blocks may not comply with) Currently just P2SH,
+ * but in the future other flags may be added, such as a soft-fork to enforce
+ * strict DER encoding.
+ *
+ * Failing one of these tests may trigger a DoS ban - see CheckInputs() for
+ * details.
+ */
+static const unsigned int MANDATORY_SCRIPT_VERIFY_FLAGS = SCRIPT_VERIFY_P2SH;
+// }
+
+// consensus/consensus.h {
+/** Flags for nSequence and nLockTime locks */
+/** Interpret sequence numbers as relative lock-time constraints. */
+static constexpr unsigned int LOCKTIME_VERIFY_SEQUENCE = (1 << 0);
+/** Use GetMedianTimePast() instead of nTime for end point timestamp. */
+static constexpr unsigned int LOCKTIME_MEDIAN_TIME_PAST = (1 << 1);
+// }
 
-/** Default for -blockmaxweight, which controls the range of block weights the mining code will create **/
-static const unsigned int DEFAULT_BLOCK_MAX_WEIGHT = MAX_BLOCK_WEIGHT - 4000;
-/** Default for -blockmintxfee, which sets the minimum feerate for a transaction in blocks created by mining code **/
-static const unsigned int DEFAULT_BLOCK_MIN_TX_FEE = 1000;
-/** The maximum weight for transactions we're willing to relay/mine */
-static const unsigned int MAX_STANDARD_TX_WEIGHT = 400000;
-/** The minimum non-witness size for transactions we're willing to relay/mine (1 segwit input + 1 P2WPKH output = 82 bytes) */
-static const unsigned int MIN_STANDARD_TX_NONWITNESS_SIZE = 82;
-/** Maximum number of signature check operations in an IsStandard() P2SH script */
-static const unsigned int MAX_P2SH_SIGOPS = 15;
-/** The maximum number of sigops we're willing to relay/mine in a single tx */
-static const unsigned int MAX_STANDARD_TX_SIGOPS_COST = MAX_BLOCK_SIGOPS_COST/5;
-/** Default for -maxmempool, maximum megabytes of mempool memory usage */
-static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 300;
-/** Default for -incrementalrelayfee, which sets the minimum feerate increase for mempool limiting or BIP 125 replacement **/
-static const unsigned int DEFAULT_INCREMENTAL_RELAY_FEE = 1000;
-/** Default for -bytespersigop */
-static const unsigned int DEFAULT_BYTES_PER_SIGOP = 20;
-/** Default for -permitbaremultisig */
-static const bool DEFAULT_PERMIT_BAREMULTISIG = true;
-/** The maximum number of witness stack items in a standard P2WSH script */
-static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;
-/** The maximum size of each witness stack item in a standard P2WSH script */
-static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;
-/** The maximum size of a standard witnessScript */
-static const unsigned int MAX_STANDARD_P2WSH_SCRIPT_SIZE = 3600;
-/** Min feerate for defining dust. Historically this has been based on the
- * minRelayTxFee, however changing the dust limit changes which transactions are
- * standard and should be done with care and ideally rarely. It makes sense to
- * only increase the dust limit after prior releases were already not creating
- * outputs below the new threshold */
-static const unsigned int DUST_RELAY_TX_FEE = 3000;
 /**
  * Standard script verification flags that standard transactions will comply
  * with. However scripts violating these flags may still be present in valid
@@ -70,49 +53,4 @@ static constexpr unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VE
                                                              SCRIPT_VERIFY_WITNESS_PUBKEYTYPE |
                                                              SCRIPT_VERIFY_CONST_SCRIPTCODE;
 
-/** For convenience, standard but not mandatory verify flags. */
-static constexpr unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;
-
-/** Used as the flags parameter to sequence and nLocktime checks in non-consensus code. */
-static constexpr unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE |
-                                                               LOCKTIME_MEDIAN_TIME_PAST;
-
-CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFee);
-
-bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFee);
-
-bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType);
-    /**
-     * Check for standard transaction types
-     * @return True if all outputs (scriptPubKeys) use only standard transaction forms
-     */
-bool IsStandardTx(const CTransaction& tx, bool permit_bare_multisig, const CFeeRate& dust_relay_fee, std::string& reason);
-    /**
-     * Check for standard transaction types
-     * @param[in] mapInputs    Map of previous transactions that have outputs we're spending
-     * @return True if all inputs (scriptSigs) use only standard transaction forms
-     */
-bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);
-    /**
-     * Check if the transaction is over standard P2WSH resources limit:
-     * 3600bytes witnessScript size, 80bytes per witness stack element, 100 witness stack elements
-     * These limits are adequate for multi-signature up to n-of-100 using OP_CHECKSIG, OP_ADD, and OP_EQUAL,
-     */
-bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);
-
-/** Compute the virtual transaction size (weight reinterpreted as bytes). */
-int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost, unsigned int bytes_per_sigop);
-int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpCost, unsigned int bytes_per_sigop);
-int64_t GetVirtualTransactionInputSize(const CTxIn& tx, int64_t nSigOpCost, unsigned int bytes_per_sigop);
-
-static inline int64_t GetVirtualTransactionSize(const CTransaction& tx)
-{
-    return GetVirtualTransactionSize(tx, 0, 0);
-}
-
-static inline int64_t GetVirtualTransactionInputSize(const CTxIn& tx)
-{
-    return GetVirtualTransactionInputSize(tx, 0, 0);
-}
-
 #endif // BITCOIN_POLICY_POLICY_H
diff --git a/script/interpreter.cpp b/script/interpreter.cpp
index 20fae2e..5bad14d 100644
--- a/script/interpreter.cpp
+++ b/script/interpreter.cpp
@@ -4,34 +4,18 @@
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
 #include <script/interpreter.h>
+#include <debugger/interpreter.h>
+
+#include <inttypes.h> // PRId64 ...
+#include <util/strencodings.h> // for Join<>
 
 #include <crypto/ripemd160.h>
 #include <crypto/sha1.h>
 #include <crypto/sha256.h>
 #include <pubkey.h>
-#include <script/script.h>
+#include <debugger/script.h>
 #include <uint256.h>
 
-typedef std::vector<unsigned char> valtype;
-
-namespace {
-
-inline bool set_success(ScriptError* ret)
-{
-    if (ret)
-        *ret = SCRIPT_ERR_OK;
-    return true;
-}
-
-inline bool set_error(ScriptError* ret, const ScriptError serror)
-{
-    if (ret)
-        *ret = serror;
-    return false;
-}
-
-} // namespace
-
 bool CastToBool(const valtype& vch)
 {
     for (unsigned int i = 0; i < vch.size(); i++)
@@ -53,12 +37,6 @@ bool CastToBool(const valtype& vch)
  */
 #define stacktop(i)  (stack.at(stack.size()+(i)))
 #define altstacktop(i)  (altstack.at(altstack.size()+(i)))
-static inline void popstack(std::vector<valtype>& stack)
-{
-    if (stack.empty())
-        throw std::runtime_error("popstack(): stack empty");
-    stack.pop_back();
-}
 
 bool static IsCompressedOrUncompressedPubKey(const valtype &vchPubKey) {
     if (vchPubKey.size() < CPubKey::COMPRESSED_PUBLIC_KEY_SIZE) {
@@ -278,7 +256,7 @@ int FindAndDelete(CScript& script, const CScript& b)
     return nFound;
 }
 
-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)
+bool StepScript(ScriptExecutionEnvironment& env, CScript::const_iterator& pc, CScript* local_script)
 {
     static const CScriptNum bnZero(0);
     static const CScriptNum bnOne(1);
@@ -288,23 +266,23 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
     // static const valtype vchZero(0);
     static const valtype vchTrue(1, 1);
 
-    CScript::const_iterator pc = script.begin();
-    CScript::const_iterator pend = script.end();
-    CScript::const_iterator pbegincodehash = script.begin();
-    opcodetype opcode;
-    valtype vchPushValue;
-    std::vector<bool> vfExec;
-    std::vector<valtype> altstack;
-    set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);
-    if (script.size() > MAX_SCRIPT_SIZE)
-        return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);
-    int nOpCount = 0;
-    bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;
+    auto& pend = env.pend;
+    auto& pbegincodehash = env.pbegincodehash;
+    auto& opcode = env.opcode;
+    auto& vchPushValue = env.vchPushValue;
+    auto& vfExec = env.vfExec;
+    auto& altstack = env.altstack;
+    auto& nOpCount = env.nOpCount;
+    auto& fRequireMinimal = env.fRequireMinimal;
+    auto& stack = env.stack;
+    auto& script = local_script ? *local_script : env.script;
+    auto& flags = env.flags;
+    auto& checker = env.checker;
+    auto& sigversion = env.sigversion;
+    auto& serror = env.serror;
+    auto& pretend_valid_map = env.pretend_valid_map;
+    auto& pretend_valid_pubkeys = env.pretend_valid_pubkeys;
 
-    try
-    {
-        while (pc < pend)
-        {
     bool fExec = !count(vfExec.begin(), vfExec.end(), false);
 
     //
@@ -344,7 +322,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
         if (fRequireMinimal && !CheckMinimalPush(vchPushValue, opcode)) {
             return set_error(serror, SCRIPT_ERR_MINIMALDATA);
         }
-                stack.push_back(vchPushValue);
+        pushstack(stack, vchPushValue);
     } else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))
     switch (opcode)
     {
@@ -371,7 +349,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
         {
             // ( -- value)
             CScriptNum bn((int)opcode - (int)(OP_1 - 1));
-                    stack.push_back(bn.getvch());
+            pushstack(stack, bn.getvch());
             // The result of these opcodes should always be the minimal way to push the data
             // they push, so no need for a CheckMinimalPush here.
         }
@@ -534,7 +512,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
         {
             if (stack.size() < 1)
                 return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    altstack.push_back(stacktop(-1));
+            pushstack(altstack, stacktop(-1));
             popstack(stack);
         }
         break;
@@ -543,7 +521,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
         {
             if (altstack.size() < 1)
                 return set_error(serror, SCRIPT_ERR_INVALID_ALTSTACK_OPERATION);
-                    stack.push_back(altstacktop(-1));
+            pushstack(stack, altstacktop(-1));
             popstack(altstack);
         }
         break;
@@ -565,8 +543,8 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
                 return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
             valtype vch1 = stacktop(-2);
             valtype vch2 = stacktop(-1);
-                    stack.push_back(vch1);
-                    stack.push_back(vch2);
+            pushstack(stack, vch1);
+            pushstack(stack, vch2);
         }
         break;
 
@@ -578,9 +556,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             valtype vch1 = stacktop(-3);
             valtype vch2 = stacktop(-2);
             valtype vch3 = stacktop(-1);
-                    stack.push_back(vch1);
-                    stack.push_back(vch2);
-                    stack.push_back(vch3);
+            pushstack(stack, vch1);
+            pushstack(stack, vch2);
+            pushstack(stack, vch3);
         }
         break;
 
@@ -591,8 +569,8 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
                 return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
             valtype vch1 = stacktop(-4);
             valtype vch2 = stacktop(-3);
-                    stack.push_back(vch1);
-                    stack.push_back(vch2);
+            pushstack(stack, vch1);
+            pushstack(stack, vch2);
         }
         break;
 
@@ -604,8 +582,8 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             valtype vch1 = stacktop(-6);
             valtype vch2 = stacktop(-5);
             stack.erase(stack.end()-6, stack.end()-4);
-                    stack.push_back(vch1);
-                    stack.push_back(vch2);
+            pushstack(stack, vch1);
+            pushstack(stack, vch2);
         }
         break;
 
@@ -626,7 +604,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
                 return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
             valtype vch = stacktop(-1);
             if (CastToBool(vch))
-                        stack.push_back(vch);
+                pushstack(stack, vch);
         }
         break;
 
@@ -634,7 +612,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
         {
             // -- stacksize
             CScriptNum bn(stack.size());
-                    stack.push_back(bn.getvch());
+            pushstack(stack, bn.getvch());
         }
         break;
 
@@ -653,7 +631,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             if (stack.size() < 1)
                 return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
             valtype vch = stacktop(-1);
-                    stack.push_back(vch);
+            pushstack(stack, vch);
         }
         break;
 
@@ -672,7 +650,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             if (stack.size() < 2)
                 return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
             valtype vch = stacktop(-2);
-                    stack.push_back(vch);
+            pushstack(stack, vch);
         }
         break;
 
@@ -690,7 +668,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             valtype vch = stacktop(-n-1);
             if (opcode == OP_ROLL)
                 stack.erase(stack.end()-n-1);
-                    stack.push_back(vch);
+            pushstack(stack, vch);
         }
         break;
 
@@ -732,7 +710,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             if (stack.size() < 1)
                 return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
             CScriptNum bn(stacktop(-1).size());
-                    stack.push_back(bn.getvch());
+            pushstack(stack, bn.getvch());
         }
         break;
 
@@ -757,7 +735,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             //    fEqual = !fEqual;
             popstack(stack);
             popstack(stack);
-                    stack.push_back(fEqual ? vchTrue : vchFalse);
+            pushstack(stack, fEqual ? vchTrue : vchFalse);
             if (opcode == OP_EQUALVERIFY)
             {
                 if (fEqual)
@@ -794,7 +772,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             default:            assert(!"invalid opcode"); break;
             }
             popstack(stack);
-                    stack.push_back(bn.getvch());
+            pushstack(stack, bn.getvch());
         }
         break;
 
@@ -843,7 +821,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             }
             popstack(stack);
             popstack(stack);
-                    stack.push_back(bn.getvch());
+            pushstack(stack, bn.getvch());
 
             if (opcode == OP_NUMEQUALVERIFY)
             {
@@ -867,7 +845,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             popstack(stack);
             popstack(stack);
             popstack(stack);
-                    stack.push_back(fValue ? vchTrue : vchFalse);
+            pushstack(stack, fValue ? vchTrue : vchFalse);
         }
         break;
 
@@ -897,7 +875,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             else if (opcode == OP_HASH256)
                 CHash256().Write(vch.data(), vch.size()).Finalize(vchHash.data());
             popstack(stack);
-                    stack.push_back(vchHash);
+            pushstack(stack, vchHash);
         }
         break;
 
@@ -931,18 +909,38 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
                     return set_error(serror, SCRIPT_ERR_SIG_FINDANDDELETE);
             }
 
+            bool fSuccess;
+            std::string sig_str = HexStr(vchSig);
+            std::string pub_str = HexStr(vchPubKey);
+            if (pretend_valid_pubkeys.count(vchPubKey)) {
+                fSuccess = pretend_valid_map.count(vchSig) && pretend_valid_map.at(vchSig) == vchPubKey;
+                if (!fSuccess) {
+                    fprintf(stderr, "note: pretend signature mismatch: got %s=%s, expected %s=%s\n",
+                        sig_str.c_str(), pub_str.c_str(),
+                        pretend_valid_map.count(vchSig) ? HexStr(pretend_valid_map.at(vchSig)).c_str() : "<null>",
+                        pub_str.c_str()
+                    );
+                }
+            } else {
                 if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, sigversion, serror)) {
                     //serror is set
+                    if (pretend_valid_map.size() > 0) {
+                        fprintf(stderr, "note: pubkey not found in pretend set: %s not in (%s)\n", pub_str.c_str(), Join<std::set<valtype>,std::vector<unsigned char>>(pretend_valid_pubkeys, ", ", JoinHexStrFun).c_str());
+                    }
                     return false;
                 }
-                    bool fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);
+                fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);
+                if (!fSuccess && pretend_valid_map.size() > 0) {
+                    fprintf(stderr, "note: pubkey not found in pretend set: %s not in (%s)\n", pub_str.c_str(), Join<std::set<valtype>,std::vector<unsigned char>>(pretend_valid_pubkeys, ", ", JoinHexStrFun).c_str());
+                }
+            }
 
             if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())
                 return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);
 
             popstack(stack);
             popstack(stack);
-                    stack.push_back(fSuccess ? vchTrue : vchFalse);
+            pushstack(stack, fSuccess ? vchTrue : vchFalse);
             if (opcode == OP_CHECKSIGVERIFY)
             {
                 if (fSuccess)
@@ -959,6 +957,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)
 
             int i = 1;
+            btc_sign_logf("stack has %zu entries [require 1]\n", stack.size());
             if ((int)stack.size() < i)
                 return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
 
@@ -973,6 +972,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             // With SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if operation fails.
             int ikey2 = nKeysCount + 2;
             i += nKeysCount;
+            btc_sign_logf("stack has %zu entries [require %d]\n", stack.size(), i);
             if ((int)stack.size() < i)
                 return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
 
@@ -981,6 +981,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
                 return set_error(serror, SCRIPT_ERR_SIG_COUNT);
             int isig = ++i;
             i += nSigsCount;
+            btc_sign_logf("stack has %zu entries [require %d]\n", stack.size(), i);
             if ((int)stack.size() < i)
                 return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
 
@@ -997,23 +998,37 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
                         return set_error(serror, SCRIPT_ERR_SIG_FINDANDDELETE);
                 }
             }
+            btc_sign_logf("scriptCode = %s\n", HexStr(scriptCode).c_str());
 
             bool fSuccess = true;
+            btc_sign_logf("looping for multisig\n");
             while (fSuccess && nSigsCount > 0)
             {
+                btc_sign_logf("loop: sigs = %d, keys = %d\n", nSigsCount, nKeysCount);
                 valtype& vchSig    = stacktop(-isig);
                 valtype& vchPubKey = stacktop(-ikey);
-
+                std::string sig_str = HexStr(vchSig);
+                std::string pub_str = HexStr(vchPubKey);
+                btc_sign_logf("- got sig %s\n", sig_str.c_str());
+                btc_sign_logf("- got key %s\n", pub_str.c_str());
+                bool fOk;
+                if (pretend_valid_pubkeys.count(vchPubKey)) {
+                    fOk = pretend_valid_map.count(vchSig) && pretend_valid_map.at(vchSig) == vchPubKey;
+                    if (!fOk) btc_sign_logf("- [mock] wrong pubkey for sig; marking as failed\n");
+                } else {
                     // Note how this makes the exact order of pubkey/signature evaluation
                     // distinguishable by CHECKMULTISIG NOT if the STRICTENC flag is set.
                     // See the script_(in)valid tests for details.
                     if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, sigversion, serror)) {
                         // serror is set
+                        btc_sign_logf("! CheckSignatureEncoding() or CheckPubKeyEncoding() failed!\n");
                         return false;
                     }
 
                     // Check signature
-                        bool fOk = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);
+                    fOk = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);
+                }
+                btc_sign_logf("- sig check %s\n", fOk ? "succeeded" : "failed");
 
                 if (fOk) {
                     isig++;
@@ -1028,6 +1043,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
                 if (nSigsCount > nKeysCount)
                     fSuccess = false;
             }
+            btc_sign_logf("loop ended in %s state\n", fSuccess ? "successful" : "failure");
 
             // Clean up stack of actual arguments
             while (i-- > 1) {
@@ -1047,11 +1063,13 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             // to removing it from the stack.
             if (stack.size() < 1)
                 return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    if ((flags & SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).size())
+            if ((flags & SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).size()) {
+                printf("\n* * * * * * *\n\nHint: with Segwit activation, the OP_CHECKMULTISIG extra argument must be set to the empty push value (0x). If you are experimenting with older scripts, you may run into a 'Dummy CHECKMULTISIG argument must be zero' error. To move past this, you need to modify the verification flags, disabling the NULLDUMMY flag specifically. I.e. call btcdeb again with -f\"-NULLDUMMY\"\n\n* * * * * * *\n\n");
                 return set_error(serror, SCRIPT_ERR_SIG_NULLDUMMY);
+            }
             popstack(stack);
 
-                    stack.push_back(fSuccess ? vchTrue : vchFalse);
+            pushstack(stack, fSuccess ? vchTrue : vchFalse);
 
             if (opcode == OP_CHECKMULTISIGVERIFY)
             {
@@ -1070,6 +1088,34 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
             // Size limits
             if (stack.size() + altstack.size() > MAX_STACK_SIZE)
                 return set_error(serror, SCRIPT_ERR_STACK_SIZE);
+
+    return true;
+}
+
+ScriptExecutionEnvironment::ScriptExecutionEnvironment(std::vector<std::vector<unsigned char> >& stack_in, const CScript& script_in, unsigned int flags_in, const BaseSignatureChecker& checker_in)
+: script(script_in)
+, pend(script.end())
+, pbegincodehash(script.begin())
+, nOpCount(0)
+, fRequireMinimal((flags_in & SCRIPT_VERIFY_MINIMALDATA) != 0)
+, stack(stack_in)
+, flags(flags_in)
+, checker(checker_in)
+{}
+
+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)
+{
+    ScriptExecutionEnvironment env(stack, script, flags, checker);
+    CScript::const_iterator pc = env.script.begin();
+    set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);
+    if (env.script.size() > MAX_SCRIPT_SIZE)
+        return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);
+
+    try {
+        while (pc < env.pend) {
+            if (!StepScript(env, pc)) {
+                return false;
+            }
         }
     }
     catch (...)
@@ -1077,7 +1123,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
         return set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);
     }
 
-    if (!vfExec.empty())
+    if (!env.vfExec.empty())
         return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);
 
     return set_success(serror);
@@ -1118,7 +1164,9 @@ public:
             if (opcode == OP_CODESEPARATOR)
                 nCodeSeparators++;
         }
+        btc_sign_logf(" << scriptCode.size()=%zu - nCodeSeparators=%d\n", scriptCode.size(), nCodeSeparators);
         ::WriteCompactSize(s, scriptCode.size() - nCodeSeparators);
+        btc_sign_logf(" << script:"); print_vec(scriptCode, btc_sign_logf); btc_sign_logf("\n");
         it = itBegin;
         while (scriptCode.GetOp(it, opcode)) {
             if (opcode == OP_CODESEPARATOR) {
@@ -1134,23 +1182,32 @@ public:
     template<typename S>
     void SerializeInput(S &s, unsigned int nInput) const {
         // In case of SIGHASH_ANYONECANPAY, only the input being signed is serialized
-        if (fAnyoneCanPay)
+        if (fAnyoneCanPay) {
             nInput = nIn;
+            btc_sign_logf("    (fAnyoneCanPay: nInput = nIn)\n");
+        }
         // Serialize the prevout
+        btc_sign_logf(" << txTo.vin[nInput=%d].prevout = %s\n", nInput, txTo.vin[nInput].prevout.ToString().c_str());
         ::Serialize(s, txTo.vin[nInput].prevout);
         // Serialize the script
-        if (nInput != nIn)
+        if (nInput != nIn) {
             // Blank out other inputs' signatures
             ::Serialize(s, CScript());
-        else
+            btc_sign_logf(" << [empty script] (reason: nInput != nIn)\n");
+        } else {
+            btc_sign_logf("(SerializeScriptCode)\n");
             SerializeScriptCode(s);
+        }
         // Serialize the nSequence
-        if (nInput != nIn && (fHashSingle || fHashNone))
+        if (nInput != nIn && (fHashSingle || fHashNone)) {
             // let the others update at will
+            btc_sign_logf(" << sequence = 0 (nInput != nIn && (fHashSingle || fHashNone))\n");
             ::Serialize(s, (int)0);
-        else
+        } else {
+            btc_sign_logf(" << txTo.vin[nInput].nSequence = %u [0x%x]\n", txTo.vin[nInput].nSequence, txTo.vin[nInput].nSequence);
             ::Serialize(s, txTo.vin[nInput].nSequence);
         }
+    }
 
     /** Serialize an output of txTo */
     template<typename S>
@@ -1165,19 +1222,28 @@ public:
     /** Serialize txTo */
     template<typename S>
     void Serialize(S &s) const {
+        btc_sign_logf("Serializing transaction\n");
         // Serialize nVersion
+        btc_sign_logf(" << txTo.nVersion (%08x)\n", txTo.nVersion);
         ::Serialize(s, txTo.nVersion);
         // Serialize vin
         unsigned int nInputs = fAnyoneCanPay ? 1 : txTo.vin.size();
+        btc_sign_logf(" << nInputs = %d [compact]\n", nInputs);
         ::WriteCompactSize(s, nInputs);
-        for (unsigned int nInput = 0; nInput < nInputs; nInput++)
+        for (unsigned int nInput = 0; nInput < nInputs; nInput++) {
+            btc_sign_logf("(serialize input %d)\n", nInput);
             SerializeInput(s, nInput);
+        }
         // Serialize vout
         unsigned int nOutputs = fHashNone ? 0 : (fHashSingle ? nIn+1 : txTo.vout.size());
+        btc_sign_logf(" << nOutputs = %d [compact]\n", nOutputs);
         ::WriteCompactSize(s, nOutputs);
-        for (unsigned int nOutput = 0; nOutput < nOutputs; nOutput++)
+        for (unsigned int nOutput = 0; nOutput < nOutputs; nOutput++) {
+            btc_sign_logf("(serialize output %d)\n", nOutput);
             SerializeOutput(s, nOutput);
+        }
         // Serialize nLockTime
+        btc_sign_logf(" << txTo.nLockTime = %d [0x%x]\n", txTo.nLockTime, txTo.nLockTime);
         ::Serialize(s, txTo.nLockTime);
     }
 };
@@ -1186,8 +1252,10 @@ template <class T>
 uint256 GetPrevoutHash(const T& txTo)
 {
     CHashWriter ss(SER_GETHASH, 0);
+    btc_sign_logf("- generating prevout hash from %zu ins\n", txTo.vin.size());
     for (const auto& txin : txTo.vin) {
         ss << txin.prevout;
+        btc_sign_logf("[+] %s\n", txin.prevout.ToString().c_str());
     }
     return ss.GetHash();
 }
@@ -1233,9 +1301,11 @@ template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTr
 template <class T>
 uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache)
 {
+    btc_sign_logf("SignatureHash(nIn=%d, nHashType=%02x, amount=%lld)\n", nIn, nHashType, amount);
     assert(nIn < txTo.vin.size());
 
     if (sigversion == SigVersion::WITNESS_V0) {
+        btc_sign_logf("- sigversion == SIGVERSION_WITNESS_V0\n");
         uint256 hashPrevouts;
         uint256 hashSequence;
         uint256 hashOutputs;
@@ -1243,43 +1313,62 @@ uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn
 
         if (!(nHashType & SIGHASH_ANYONECANPAY)) {
             hashPrevouts = cacheready ? cache->hashPrevouts : GetPrevoutHash(txTo);
+            btc_sign_logf("  hashPrevouts = %s\n", hashPrevouts.ToString().c_str());
         }
 
         if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {
             hashSequence = cacheready ? cache->hashSequence : GetSequenceHash(txTo);
+            btc_sign_logf("  hashSequence = %s\n", hashSequence.ToString().c_str());
         }
 
 
         if ((nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {
             hashOutputs = cacheready ? cache->hashOutputs : GetOutputsHash(txTo);
+            btc_sign_logf("  hashOutputs [!single] = %s\n", hashOutputs.ToString().c_str());
         } else if ((nHashType & 0x1f) == SIGHASH_SINGLE && nIn < txTo.vout.size()) {
             CHashWriter ss(SER_GETHASH, 0);
             ss << txTo.vout[nIn];
             hashOutputs = ss.GetHash();
+            btc_sign_logf("  hashOutputs [single] = %s\n", hashOutputs.ToString().c_str());
         }
 
+        CHashWriter::debug = btc_enabled(btc_sighash_logf);
         CHashWriter ss(SER_GETHASH, 0);
         // Version
+        btc_sign_logf("SERIALIZING:\n");
         ss << txTo.nVersion;
+        btc_sign_logf(" << txTo.nVersion = %d\n", txTo.nVersion);
         // Input prevouts/nSequence (none/all, depending on flags)
         ss << hashPrevouts;
+        btc_sign_logf(" << hashPrevouts\n");
         ss << hashSequence;
+        btc_sign_logf(" << hashSequence\n");
         // The input being signed (replacing the scriptSig with scriptCode + amount)
         // The prevout may already be contained in hashPrevout, and the nSequence
         // may already be contain in hashSequence.
         ss << txTo.vin[nIn].prevout;
+        btc_sign_logf(" << txTo.vin[nIn=%d].prevout = %s\n", nIn, txTo.vin[nIn].prevout.ToString().c_str());
         ss << scriptCode;
+        btc_sign_logf(" << scriptCode\n");
         ss << amount;
+        btc_sign_logf(" << amount = %" PRId64 "\n", amount);
         ss << txTo.vin[nIn].nSequence;
+        btc_sign_logf(" << txTo.vin[nIn].nSequence = %u (0x%x)\n", txTo.vin[nIn].nSequence, txTo.vin[nIn].nSequence);
         // Outputs (none/one/all, depending on flags)
         ss << hashOutputs;
+        btc_sign_logf(" << hashOutputs\n");
         // Locktime
         ss << txTo.nLockTime;
+        btc_sign_logf(" << txTo.nLockTime = %d\n", txTo.nLockTime);
         // Sighash type
         ss << nHashType;
-
-        return ss.GetHash();
+        btc_sign_logf(" << nHashType = %02x\n", nHashType);
+        CHashWriter::debug = false;
+        uint256 sighash = ss.GetHash();
+        btc_sign_logf("RESULTING HASH = %s\n", sighash.ToString().c_str());
+        return sighash;
     }
+    btc_sign_logf("- sigversion = SIGVERSION_BASE (non-segwit style)\n");
 
     static const uint256 one(uint256S("0000000000000000000000000000000000000000000000000000000000000001"));
 
@@ -1287,6 +1376,7 @@ uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn
     if ((nHashType & 0x1f) == SIGHASH_SINGLE) {
         if (nIn >= txTo.vout.size()) {
             //  nOut out of range
+            btc_sign_logf("  nIn >= txTo.vout.size()\n");
             return one;
         }
     }
@@ -1295,35 +1385,52 @@ uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn
     CTransactionSignatureSerializer<T> txTmp(txTo, scriptCode, nIn, nHashType);
 
     // Serialize and hash
+    CHashWriter::debug = btc_enabled(btc_sighash_logf);
     CHashWriter ss(SER_GETHASH, 0);
     ss << txTmp << nHashType;
+    CHashWriter::debug = false;
     return ss.GetHash();
 }
 
 template <class T>
 bool GenericTransactionSignatureChecker<T>::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const
 {
-    return pubkey.Verify(sighash, vchSig);
+    btc_sign_logf("  pubkey.Verify(sig="); print_vec(vchSig, btc_sign_logf); btc_sign_logf(", sighash=%s):\n", sighash.ToString().c_str());
+    bool res = pubkey.Verify(sighash, vchSig);
+    btc_sign_logf("  result: %s\n", res ? "success" : "FAILURE");
+    return res;
 }
 
 template <class T>
 bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const
 {
+    btc_sign_logf("GenericTransactionSignatureChecker::CheckSig(%zu len sig, %zu len pubkey, sigversion=%d)\n", vchSigIn.size(), vchPubKey.size(), sigversion);
+    btc_sign_logf("  sig         = "); print_vec(vchSigIn, btc_sign_logf); btc_sign_logf("\n");
+    btc_sign_logf("  pub key     = "); print_vec(vchPubKey, btc_sign_logf); btc_sign_logf("\n");
+    btc_sign_logf("  script code = "); print_vec(scriptCode, btc_sign_logf); btc_sign_logf("\n");
     CPubKey pubkey(vchPubKey);
-    if (!pubkey.IsValid())
+    if (!pubkey.IsValid()) {
+        btc_sign_logf("- failed: pubkey is not valid\n");
         return false;
+    }
 
     // Hash type is one byte tacked on to the end of the signature
     std::vector<unsigned char> vchSig(vchSigIn);
-    if (vchSig.empty())
+    if (vchSig.empty()) {
+        btc_sign_logf("- failed: signature is empty\n");
         return false;
+    }
     int nHashType = vchSig.back();
     vchSig.pop_back();
+    btc_sign_logf("  hash type   = %02x (%s)\n", nHashType, hashtype_str(nHashType).c_str());
 
     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);
+    btc_sign_logf("  sighash     = %s\n", sighash.ToString().c_str());
 
-    if (!VerifySignature(vchSig, pubkey, sighash))
+    if (!VerifySignature(vchSig, pubkey, sighash)) {
+        btc_sign_logf("- failed: VerifySignature() failed\n");
         return false;
+    }
 
     return true;
 }
diff --git a/script/interpreter.h b/script/interpreter.h
index 276ff9a..fa4944f 100644
--- a/script/interpreter.h
+++ b/script/interpreter.h
@@ -185,6 +185,28 @@ public:
 using TransactionSignatureChecker = GenericTransactionSignatureChecker<CTransaction>;
 using MutableTransactionSignatureChecker = GenericTransactionSignatureChecker<CMutableTransaction>;
 
+struct ScriptExecutionEnvironment {
+    CScript script;
+    CScript::const_iterator pend;
+    CScript::const_iterator pbegincodehash;
+    opcodetype opcode;
+    std::vector<uint8_t> vchPushValue;
+    std::vector<bool> vfExec;
+    std::vector<std::vector<uint8_t>> altstack;
+    int nOpCount;
+    bool fRequireMinimal;
+    std::vector<std::vector<unsigned char> >& stack;
+    unsigned int flags;
+    const BaseSignatureChecker& checker;
+    SigVersion sigversion;
+    ScriptError* serror;
+    std::map<std::vector<unsigned char>,std::vector<unsigned char>> pretend_valid_map;
+    std::set<std::vector<unsigned char>> pretend_valid_pubkeys;
+    ScriptExecutionEnvironment(std::vector<std::vector<unsigned char> >& stack_in, const CScript& script_in, unsigned int flags_in, const BaseSignatureChecker& checker_in);
+};
+
+bool StepScript(ScriptExecutionEnvironment& env, CScript::const_iterator& pc, CScript* local_script = nullptr);
+
 bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);
 bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = nullptr);
 
diff --git a/script/script.h b/script/script.h
index 6355b8a..e3537ec 100644
--- a/script/script.h
+++ b/script/script.h
@@ -317,6 +317,8 @@ public:
         return m_value;
     }
 
+    int64_t getint64() const { return m_value; }
+
     std::vector<unsigned char> getvch() const
     {
         return serialize(m_value);
diff --git a/util/strencodings.h b/util/strencodings.h
index e35b2ab..a8aad78 100644
--- a/util/strencodings.h
+++ b/util/strencodings.h
@@ -16,6 +16,8 @@
 #include <string>
 #include <vector>
 
+#include <functional>
+
 #define ARRAYLEN(array)     (sizeof(array)/sizeof((array)[0]))
 
 /** Used by SanitizeString() */
@@ -171,6 +173,18 @@ bool TimingResistantEqual(const T& a, const T& b)
  */
 NODISCARD bool ParseFixedPoint(const std::string &val, int decimals, int64_t *amount_out);
 
+template <typename Tset, typename Tel>
+inline std::string Join(const Tset& iterable, const std::string& sep,
+        std::function<std::string(const Tel&)> strfun) {
+    std::string rv = "";
+    for (const Tel& el : iterable) {
+        rv += (rv[0] ? ", " : "") + strfun(el);
+    }
+    return rv;
+}
+
+inline std::string JoinHexStrFun(const std::vector<unsigned char>& t) { return HexStr(t); }
+
 /** Convert from one power-of-2 number base to another. */
 template<int frombits, int tobits, bool pad, typename O, typename I>
 bool ConvertBits(const O& outfn, I it, I end) {
